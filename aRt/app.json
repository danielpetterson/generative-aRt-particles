[{"name":"app.R","content":"library(shiny)\nlibrary(shinythemes)\nlibrary(shinyBS)\nlibrary(particles)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(ggforce)\nlibrary(gganimate)\nlibrary(transformr)\nlibrary(tidygraph)\nlibrary(colourpicker)\nlibrary(RColorBrewer)\nlibrary(shinyalert)\nlibrary(DT)\n\n# Define UI for application\nui <- fluidPage(\n        theme = shinytheme(\"slate\"),\n        titlePanel(\"Generative aRt with R\"),\n        fluidRow(\n            column(3,\n                   wellPanel(\n                     selectInput(\"section\",\n                                 \"Section\",\n                                 c(\"Data\", \"Modify Forces/Constraints\", \"Display\"),\n                                 selected = \"Data\"),\n                     conditionalPanel(\n                       condition = \"input.section == 'Data'\",\n                       \n                       numericInput(\"seed\",\n                                    \"Seed\",\n                                    1, min = 1, max = 1000),\n                       bsTooltip(\"seed\", \"Sets the seed for the pseudorandom number generator\",\n                                 \"right\", options = list(container = \"body\")),\n                       selectInput(\"origin\",\n                                   \"Origin Type\",\n                                   c(\"Single Point\", \"Within Range\"),\n                                   selected = \"Single Point\"),\n                       bsTooltip(\"origin\", \"Would you like your particles to start from a single point or within a predefined range?\",\n                                 \"right\", options = list(container = \"body\")),\n                       conditionalPanel(\n                         condition = \"input.origin == 'Within Range'\",\n                       sliderInput(\"xlims_data\",\n                                   \"Range of Initial X Values\",\n                                   -1000, 1000, value = c(-100,100)),\n                       sliderInput(\"ylims_data\",\n                                   \"Range of Initial Y Values\",\n                                   -1000, 1000, value = c(-100,100))),\n                       numericInput(\"n_sims\",\n                                    \"Number of Simulations\",\n                                    5, min = 1, max = 35),\n                       bsTooltip(\"n_sims\", \"Select the number of simulations to plot\",\n                                 \"right\", options = list(container = \"body\")),\n                       numericInput(\"max_dist_sims\",\n                                    \"Maximum Distance Between Simulations\",\n                                    50000, min = 1, max = 10000000),\n                       bsTooltip(\"max_dist_sims\", \"Set the maximum distance between simulation start points\",\n                                 \"right\", options = list(container = \"body\")),\n                       numericInput(\"n_particles\",\n                                    \"Number of Particles per Simulation\",\n                                    20, min = 1, max = 500),\n                       bsTooltip(\"n_particles\", \"Set the number of particles per simulation\",\n                                 \"right\", options = list(container = \"body\")),\n                       sliderInput(\"evolutions\",\n                                   \"Number of Evolutions\",\n                                   1,300, 20, step = 1),\n                       bsTooltip(\"evolutions\", \"Each evolution is one time step in which forces will act on a particle\",\n                                 \"right\", options = list(container = \"body\")),\n                       sliderInput(\"subset_evolutions\",\n                                   \"Subset Evolutions\",\n                                   0, 300, value = c(0,300)),\n                       bsTooltip(\"subset_evolutions\", \"Modify this to only plot data from a smaller timeframe\",\n                                 \"right\", options = list(container = \"body\")),\n                       numericInput(\"jit\",\n                                    \"Jitter\",\n                                    20, min = 1, max = 500),\n                       bsTooltip(\"jit\", \"Jitter shifts all particle locations slightly to avoid overlap\",\n                                 \"right\", options = list(container = \"body\")),\n                       sliderInput(\"vel_dec\",\n                                   \"Velocity Decay\",\n                                    0, 1, 0.3, step = 0.01),\n                       bsTooltip(\"vel_dec\", \"Set the rate of speed decay\",\n                                 \"right\", options = list(container = \"body\"))\n                   ),\n                   conditionalPanel(\n                     condition = \"input.section == 'Modify Forces/Constraints'\",\n                     selectInput(\"forces_and_limits\", \"Forces and Constraints:\",\n                               c(\"Random Force\" = \"f_rand\",\n                                 \"Collision Force\" = \"f_coll\",\n                                 \"Manybody Force\" = \"f_mb\",\n                                 \"Mean Force\" = \"f_mean\",\n                                 \"Attract to Point\" = \"f_point\",\n                                 \"Velocity Constraint\" = \"vel_lims\"\n                                 ),\n                               selected = \"Random Force\"),\n                   conditionalPanel(\n                     condition = \"input.forces_and_limits == 'f_rand'\",\n                     selectInput(\"rand_apply\",\n                                 \"Apply Force?\",\n                                 c(\"Yes\", \"No\"),\n                                 selected = \"Yes\"),\n                     sliderInput(\"xlims_rand\", \"X-axis Bounds\",\n                                 -1000, 1000, value = c(-1000,1000), step = 1),\n                     sliderInput(\"ylims_rand\", \"Y-axis Bounds\",\n                                 -1000, 1000, value = c(-1000,1000), step = 1)),\n                   conditionalPanel(\n                     condition = \"input.forces_and_limits == 'f_coll'\",\n                     sliderInput(\"coll_str\",\n                                  \"Strength\",\n                                  0, 1, value = 0, step = 0.01),\n                     numericInput(\"coll_rad\",\n                                  \"Radius\",\n                                  0, min = 0, max = 500)),\n                   conditionalPanel(\n                     condition = \"input.forces_and_limits == 'f_mb'\",\n                     numericInput(\"mb_str\",\n                                  \"Strength\",\n                                  0, min = -500, max = 500)),\n                   conditionalPanel(\n                     condition = \"input.forces_and_limits == 'f_mean'\",\n                     selectInput(\"mf_apply\",\n                                 \"Apply Force?\",\n                                 c(\"Yes\", \"No\"),\n                                 selected = \"No\"),\n                     selectInput(\"mean_self\",\n                                 \"Include Own Speed\",\n                                 c(\"Yes\", \"No\"),\n                                 selected = \"No\")),\n                   conditionalPanel(\n                     h5(\"Click on the image to choose a point\"),\n                     condition = \"input.forces_and_limits == 'f_point'\",\n                     sliderInput(\"x_str\",\n                                 \"X-Axis Strength\",\n                                 0, 10, value = 0, step = 0.1),\n                     sliderInput(\"y_str\",\n                                 \"Y-Axis Strength\",\n                                 0, 10, value = 0, step = 0.1)),\n                   conditionalPanel(\n                     condition = \"input.forces_and_limits == 'vel_lims'\",\n                     sliderInput(\"v_lims\", \"Velocity Boundaries\",\n                                 -1000, 1000, value = c(-1000,1000), step = 1)),\n                   ),\n                     conditionalPanel(\n                       condition = \"input.section == 'Display'\",\n                       selectInput(\"geom_type\",\n                                   \"Geom Type\",\n                                   c(\"Point\", \"Curve\", \"Segment\", \"Path\"),\n                                   selected = \"Point\"),\n                       bsTooltip(\"geom_type\", \"Select the type of ggplot2 geom to use. Point shows only that location, the other geoms link locations based on the specific particle (Segment, Curve) or the neighbouring data rows (Path).\",\n                                 \"right\", options = list(container = \"body\")),\n                       colourInput(\"col_element\", \"Colour Palette\", \"white\",\n                                    showColour = \"background\"),\n                       bsTooltip(\"col_element\", \"Select your desired colours and press the button below to add them to the palette. If more colour values are needed than are provided then intermediate colours will be interpolated.\",\n                                 \"right\", options = list(container = \"body\")),\n                       actionButton(\"col_select\", \"Add Colour\"),\n                       actionButton(\"col_clear\", \"Clear Palette\"),\n                       bsTooltip(\"col_clear\", \"Clears the colour palette. Images will be displayed in white until at least two colours are added to the palette.\",\n                                 \"right\", options = list(container = \"body\")),\n                       selectInput(\"col_factor\",\n                                   \"Colour Factor\",\n                                   c(\"Time\", \"Particle\", \"Simulation\"),\n                                   selected = \"Time\"),\n                       bsTooltip(\"col_factor\", \"Do you want the colour to change based of the time step, the individual particle or the simulation that the particles came from?\",\n                                 \"right\", options = list(container = \"body\")),\n                        selectInput(\"coord_sys\",\n                                    \"Coordinate System\",\n                                    c(\"Cartesian\", \"Flipped\", \"Polar X\", \"Polar Y\"),\n                                    selected = \"Cartesian\"),\n                       bsTooltip(\"coord_sys\", \"Cartesian is how coordinates are normally plotted. Flipped revereses the X and Y values. Polar X uses the pollar coordinate system relative to X.\",\n                                 \"right\", options = list(container = \"body\")),\n                       sliderInput(\"alph_init\", \"Initial Opacity\",\n                                   0, 1, 0.8, step = 0.05),\n                       bsTooltip(\"alph_init\", \"How opaque a point is at the start.\",\n                                 \"right\", options = list(container = \"body\")),\n                       sliderInput(\"alph_dec\", \"Opacity Decay\",\n                                   0, 1, 0.05, step = 0.001),\n                       bsTooltip(\"alph_dec\", \"Higher values increase transparency at a greater rate.\",\n                                 \"right\", options = list(container = \"body\")),\n                       colourInput(\n                         \"backg_col\", \"Background Colour\", \"black\",\n                         showColour = \"background\"),\n                       sliderInput(\"pathsize\", \"Size\",\n                                   0, 3, value = 0.2, step = 0.01),\n                       bsTooltip(\"pathsize\", \"The size of the plotted points/lines.\",\n                                 \"right\", options = list(container = \"body\")),\n                       sliderInput(\"xlims_disp\", \"X-axis Scale\",\n                                   -3, 3, value = c(-1,1), step = 0.001),\n                       sliderInput(\"ylims_disp\", \"Y-axis Scale\",\n                                   -3, 3, value = c(-1,1), step = 0.001)),\n                   \n\n)),mainPanel(\n  fluidRow(actionButton(\"gen_data\", \"Generate Data\"), # Initial data is generated when this event is observed\n           bsTooltip(\"gen_data\", \"Data must be generated before creating the image.\",\n                     \"right\", options = list(container = \"body\")),\n           actionButton(\"show_data\", \"Show/Hide Data\"), #Toggles Dataframe display\n           actionButton(\"gen_image\", \"Update Output\"), # Updates the image/animation\n           bsTooltip(\"gen_image\", \"Click here to update the image.\",\n                     \"right\", options = list(container = \"body\")),\n           actionButton(\"output_type\", \"Toggle Image/Animation\"), # Toggles between output type. Animations take longer to render\n           conditionalPanel(\n             condition = \"input.output_type%2 == 0\",\n             downloadButton('save', 'Download image')), # Download button appears when not set to output animation\n           bsTooltip(\"save\", \"Download a copy of your masterpiece. Maybe print it out and put it on the fridge!\",\n                     \"right\", options = list(container = \"body\")),\n           conditionalPanel(\n             condition = \"input.show_data%2 == 0\",\n             DT::DTOutput(\"data\")), # Table showing df\n           plotOutput(\"image\",click=\"imageclick\") # Main image\n\n    \n    ))))\n\n\n# Define server logic\nserver <- function(input, output) {\n  \n  # Modal that presents when the app opens\n  shinyalert(\n    title = \"App Info\",\n    text = \"This app uses data generated from a particle physics simulation to create images. When you've selected the settings you want, hit 'Generate Data' followed by 'Update Image'. Hover over any options for more information\",\n    size = \"s\", \n    closeOnEsc = TRUE,\n    closeOnClickOutside = TRUE,\n    html = FALSE,\n    type = \"info\",\n    showConfirmButton = TRUE,\n    showCancelButton = FALSE,\n    confirmButtonText = \"OK\",\n    confirmButtonCol = \"#AEDEF4\",\n    timer = 0,\n    imageUrl = \"\",\n    animation = FALSE\n  )\n  \n  # Creates data using all non-display parameters\n  generate_sim_data <- function(origin,\n                                ns,\n                                max_dist,\n                                n,\n                                evolutions,\n                                evol_subset,\n                                vel_dec,\n                                xlims,\n                                ylims,\n                                alpha_init,\n                                alpha_dec,\n                                jit,\n                                pathsize,\n                                seed,\n                                rand_apply,\n                                rand_x,\n                                rand_y,\n                                coll_strength,\n                                coll_rad,\n                                mb_strength,\n                                mf_apply,\n                                mean_self_include,\n                                x_force_str,\n                                x_force_loc,\n                                y_force_str,\n                                y_force_loc,\n                                vel_limits){\n    l<-c()\n    i=1\n    \n    # Convert text input to bool for mean force parameter\n    if (mean_self_include == 'Yes') {\n      self_include <- TRUE\n    } else {\n      self_include <- FALSE\n    }\n    \n    set.seed(seed)\n    \n    # Loop for each simulation\n    while(i <= ns) {\n      # Generate starting point coordinates\n      if(origin == \"Single Point\") {\n        loc <- isolate(runif(2, min = -max_dist/2, max = max_dist/2))\n        x <- isolate(runif(1, min = loc[1] - abs(xlims[1]), max = loc[1] + abs(xlims[2])))\n        y <- isolate(runif(1, min = loc[2] - abs(ylims[1]), max = loc[2] + abs(ylims[2])))\n      } else {\n        x <- isolate(runif(n, min = xlims[1], max = xlims[2]))\n        y <- isolate(runif(n, min = ylims[1], max = ylims[2]))\n      }\n      # Generate initial velocity of particle\n      x_vel <- runif(n, min = -1, max = 1)\n      y_vel <- runif(n, min = -1, max = 1)\n      \n      b <- create_empty(n) %>% \n        simulate(velocity_decay = vel_dec, setup = predefined_genesis(x,y,x_vel,y_vel))\n      \n      if(rand_apply == 'Yes') {\n        b %<>% wield(random_force, xmin=min(rand_x), xmax=max(rand_x), ymin=min(rand_y), ymax=max(rand_y))\n      }\n        b %<>% wield(collision_force, strength=coll_strength, radius=coll_rad) # Apply collision force\n        b %<>% wield(manybody_force, strength = mb_strength) # Apply manybody force\n      if(mf_apply == 'Yes') {\n        b %<>% wield(mean_force, include_self = self_include) # Apply mean force\n      }\n        b %<>% wield(x_force, strength=x_force_str, x=x_force_loc) # The x component to the 'Attract to Point' force\n        b %<>% wield(y_force, strength=y_force_str, y=y_force_loc) # The y component to the 'Attract to Point' force\n        b %<>% impose(velocity_constraint, vmin=min(vel_limits), vmax=max(vel_limits)) # Impose upper and lower velocity bounds\n        b %<>% evolve(evolutions, record) # Evolve over number of evolutions\n      \n        \n      l<-c(l,b) # Append simulation object to list\n      i=i+1\n    }\n    # Extract simulation history\n    hist <- l[seq(6, length(l), 6)]\n    list <- unlist(hist, recursive = FALSE)\n    \n    # Bind x,y coordinates by row\n    traces <- data.frame(do.call(rbind, lapply(list, position)))\n    names(traces) <- c('x', 'y')\n    \n    # Introduce jitter to avoid identical endpoints\n    traces$x <- jitter(traces$x, jit)\n    traces$y <- jitter(traces$y, jit)\n    \n    # Assign particle and simulation identifiers\n    traces$particle <- as.factor(rep(1:n, evolutions))\n    traces$sim <- as.factor(rep(1:ns, each=evolutions*n))\n    traces$time <- rep(1:evolutions, each=n)\n    traces$alpha <- alpha_init * (1 - alpha_dec)^(traces$time-1)\n    \n    # Create xend and yend values\n    traces_end <- traces %>%\n      dplyr::mutate(time = time - 1) %>%\n      dplyr::filter(time > 0)\n    \n    traces <- traces %>%\n      dplyr::filter(time < max(time))\n    \n    traces$xend <- traces_end$x\n    traces$yend <- traces_end$y\n    traces$time <- as.factor(traces$time)\n    traces$pathsize <- pathsize\n    \n    # Apply subsetting of time steps/evolutions\n    traces %<>% filter(as.numeric(time) >= min(evol_subset) & as.numeric(time) <= max(evol_subset))\n    \n    return(traces)\n  }\n    \n\n\n    values <- reactiveValues() # Create object for restoring reactive values\n    \n    # Generate and display data when button press observed\n    observeEvent(input$gen_data, {\n        values$df <- isolate(reactive({generate_sim_data(input$origin,\n                                                     input$n_sims,\n                                                     input$max_dist_sims,\n                                                     input$n_particles,\n                                                     input$evolutions,\n                                                     input$subset_evolutions,\n                                                     input$vel_dec,\n                                                     input$xlims_data,\n                                                     input$ylims_data,\n                                                     input$alph_init,\n                                                     input$alph_dec,\n                                                     input$jit,\n                                                     input$pathsize,\n                                                     input$seed,\n                                                     input$rand_apply,\n                                                     input$xlims_rand,\n                                                     input$ylims_rand,\n                                                     input$coll_str,\n                                                     input$coll_rad,\n                                                     input$mb_str,\n                                                     input$mf_apply,\n                                                     input$mean_self,\n                                                     input$x_str,\n                                                     input$imageclick[[\"x\"]],\n                                                     input$y_str,\n                                                     input$imageclick[[\"y\"]],\n                                                     input$v_lims\n                                                    )}))\n        # Set default palette to vector containing only white\n        values$colour_palette <- rep(\"white\", length(values$df()$x))\n        # Display data table\n        output$data <- DT::renderDT(values$df(),options =list(pageLength = 5))\n    })\n    \n\n    \n    # Adds selected colour to vector of colours for palette generation\n    observeEvent(input$col_select, {\n      values$colour_palette_vec <- append(values$colour_palette_vec,as.character(input$col_element)) \n    })\n    \n    # Replaces palette with empty vector when \"Clear Palette\" button is hit \n    observeEvent(input$col_clear, {\n      values$colour_palette_vec <- character()\n    })\n    \n    observeEvent(input$gen_data, {\n    # Generates image or animation when \"Update Output\" button is hit\n    observeEvent(input$gen_image, {\n      \n      # Specifies what variable to change colour on\n      if (input$col_factor == \"Time\") {\n        colour_factor <-as.factor(values$df()$time)\n        num_colours <- max(as.numeric(values$df()$time))\n      } else if (input$col_factor == \"Particle\") {\n        colour_factor <- as.factor(values$df()$particle)\n        num_colours <- max(as.numeric(values$df()$particle))\n      } else if (input$col_factor == \"Simulation\") {\n        colour_factor <- as.factor(values$df()$sim)\n        num_colours <- max(as.numeric(values$df()$sim))\n      }\n      \n      if (length(values$colour_palette_vec)>=2) {\n        # Creates function to interpolate colours from user defined palette\n        palette_maker <- grDevices::colorRampPalette(values$colour_palette_vec)\n        values$colour_palette <- palette_maker(num_colours)\n      }\n      \n      # Basic ggplot parameters for output\n      img_base<-ggplot2::ggplot(values$df()) +\n        # Sets theme\n        ggplot2::theme_void() + \n        # Removes legend and sets plot background colour\n        ggplot2::theme(legend.position = 'none', panel.background = element_rect(fill = input$backg_col)) +\n        # Sets xlim to the most extreme values observed across all simulations\n        ggplot2::xlim(min(values$df()$x)*abs(input$xlims_disp[1]),max(values$df()$x)*abs(input$xlims_disp[2])) +\n        # Sets ylim to the most extreme values observed across all simulations\n        ggplot2::ylim(min(values$df()$y)*abs(input$ylims_disp[1]),max(values$df()$y)*abs(input$ylims_disp[2])) +\n        # Assigns defined colour palette to ggplot object\n        ggplot2::scale_color_manual(values=values$colour_palette) \n      \n      # Append selected geom to img_base\n      if (input$geom_type == \"Point\") {\n           img <- img_base + \n             ggplot2::geom_point(aes(x = x,\n                                     y = y,\n                                     colour = colour_factor,\n                                     alpha = alpha,\n                                     group = particle),\n                                     size = values$df()$pathsize)\n      } else if (input$geom_type == \"Curve\") {\n        img <- img_base + \n            ggplot2::geom_curve(aes(x = x,\n                                    y = y,\n                                    colour = colour_factor,\n                                    alpha = alpha,\n                                    xend = xend,\n                                    yend = yend), \n                                    size = values$df()$pathsize)\n      } else if (input$geom_type == \"Segment\") {\n        img <- img_base + \n          ggplot2::geom_segment(aes(x = x,\n                                    y = y,\n                                    colour = colour_factor,\n                                    alpha = alpha,\n                                    xend = xend,\n                                    yend = yend), \n                                    size = values$df()$pathsize[1])\n      } else if (input$geom_type == \"Path\") {\n        img <- img_base + \n          ggplot2::geom_path(aes(x = x,\n                                 y = y,\n                                 colour = colour_factor,\n                                 alpha = alpha), \n                                 size = values$df()$pathsize[1])\n      } \n      \n      # Set coordinate system used to plot\n      if (input$coord_sys == \"Cartesian\") {\n        img_final <- img + ggplot2::coord_cartesian()\n      } else if (input$coord_sys == \"Flipped\") {\n        img_final <- img + ggplot2::coord_flip()\n      } else if (input$coord_sys == \"Polar X\") {\n        img_final <- img + ggplot2::coord_polar(theta=\"x\")\n      } else if (input$coord_sys == \"Polar Y\") {\n        img_final <- img + ggplot2::coord_polar(theta=\"y\")\n      }\n      \n        \n        \n        \n      if (input$output_type%%2==0) {\n      output$image <- renderPlot({img_final}, height=800, width=800)\n      } else  {\n        output$image <- renderImage({\n          \n          # A temp file to save the output\n          outfile <- tempfile(fileext='.gif')\n          \n          # Make the animation\n          img_anim = img_final +\n            gganimate::transition_time(time = as.numeric(time))  +\n            gganimate::ease_aes('linear') +\n            gganimate::shadow_wake(wake_length=0.5)\n          \n          anim_save(\"outfile.gif\", animate(img_anim))\n          \n          # Return a list containing the filename\n          list(src = \"outfile.gif\",\n               contentType = 'image/gif',\n               width = 800,\n               height = 800\n          )}, deleteFile = TRUE)\n        }\n      # Save image to file\n      output$save <- downloadHandler(\n        file = \"aRtwork.png\" , # Set default filename\n        content = function(file) {\n          ggsave(img_final, filename = file)\n          png(file = file, units=\"in\", width=25, height=25, res=300)\n          dev.off()\n        })\n          \n})})\n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\n\n# Update version deployed to web\n#library(rsconnect)\n#deployApp()\n","type":"text"}]
